{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import sympy as sp #write bubble sort algorithm def bubble_sort ( items ): ''' :param items ''' for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] print ( bubble_sort ( 5 ))","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. 1 2 3 4 5 def bubble_sort ( items ): for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import sympy as sp #write bubble sort algorithm def bubble_sort ( items ): ''' :param items ''' for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] print ( bubble_sort ( 5 ))","title":"Project layout"},{"location":"test-reference/","text":"Test module f ( x ) function description Source code in sourcecode\\test.py def f ( x ): ''' function description ''' return ( 2 * x )","title":"Test module"},{"location":"test-reference/#test-module","text":"","title":"Test module"},{"location":"test-reference/#sourcecode.test.f","text":"function description Source code in sourcecode\\test.py def f ( x ): ''' function description ''' return ( 2 * x )","title":"f()"},{"location":"Chapter%201/exercise%201/","text":"Exercise 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 import sympy as sp #write bubble sort algorithm def bubble_sort ( items ): ''' :param items ''' for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] print ( bubble_sort ( 5 ))","title":"Exercise 1"},{"location":"Chapter%201/exercise%201/#exercise-1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 import sympy as sp #write bubble sort algorithm def bubble_sort ( items ): ''' :param items ''' for i in range ( len ( items )): for j in range ( len ( items ) - 1 - i ): if items [ j ] > items [ j + 1 ]: items [ j ], items [ j + 1 ] = items [ j + 1 ], items [ j ] print ( bubble_sort ( 5 ))","title":"Exercise 1"},{"location":"chapter3/3_3_1_Bisection%20Method/","text":"ALGORITHM bisection ( f , a , b , tol ) Bisection algorithm for root finding of a single-variable function. Parameters: Name Type Description Default f function function returning a number. f must be continuous, and f(a) and f(b) must have opposite signs. required a float one end of the bracketing interval [a, b]. required b float other end of the bracketing interval [a, b]. required tol float nonnegative tolerance. required Returns: Type Description c (float) root Source code in chapter3\\3_3_1 bisection method.py def bisection ( f , a , b , tol ): \"\"\"Bisection algorithm for root finding of a single-variable function. Args: f (function): function returning a number. f must be continuous, and f(a) and f(b) must have opposite signs. a (float): one end of the bracketing interval [a, b]. b (float): other end of the bracketing interval [a, b]. tol (float): nonnegative tolerance. Returns: c (float): root \"\"\" c = 0.5 * ( a + b ) while abs ( f ( c )) > tol : if f ( a ) * f ( c ) > 0 : a = c else : b = c c = 0.5 * ( a + b ) return ( c ) EXAMPLE 1 1 2 3 4 def f ( x ): return ( x ** 2 - 1 ) print ( bisection ( f , 0 , 3 , 1e-12 )) OUTCOME c = 1.0000000000004547 EXAMPLE 2 1 2 3 4 def f ( x ): return ( x ** 2 - x - 1 ) print ( bisection ( f , 0 , 10 , 1e-6 )) OUTCOME c = 1.6180336475372314","title":"3.3.1. Bisection method"},{"location":"chapter3/3_3_1_Bisection%20Method/#algorithm","text":"","title":"ALGORITHM"},{"location":"chapter3/3_3_1_Bisection%20Method/#sourcecode.chapter3.3_3_1 Bisection Method.bisection","text":"Bisection algorithm for root finding of a single-variable function. Parameters: Name Type Description Default f function function returning a number. f must be continuous, and f(a) and f(b) must have opposite signs. required a float one end of the bracketing interval [a, b]. required b float other end of the bracketing interval [a, b]. required tol float nonnegative tolerance. required Returns: Type Description c (float) root Source code in chapter3\\3_3_1 bisection method.py def bisection ( f , a , b , tol ): \"\"\"Bisection algorithm for root finding of a single-variable function. Args: f (function): function returning a number. f must be continuous, and f(a) and f(b) must have opposite signs. a (float): one end of the bracketing interval [a, b]. b (float): other end of the bracketing interval [a, b]. tol (float): nonnegative tolerance. Returns: c (float): root \"\"\" c = 0.5 * ( a + b ) while abs ( f ( c )) > tol : if f ( a ) * f ( c ) > 0 : a = c else : b = c c = 0.5 * ( a + b ) return ( c )","title":"bisection()"},{"location":"chapter3/3_3_1_Bisection%20Method/#example-1","text":"1 2 3 4 def f ( x ): return ( x ** 2 - 1 ) print ( bisection ( f , 0 , 3 , 1e-12 ))","title":"EXAMPLE 1"},{"location":"chapter3/3_3_1_Bisection%20Method/#outcome","text":"c = 1.0000000000004547","title":"OUTCOME"},{"location":"chapter3/3_3_1_Bisection%20Method/#example-2","text":"1 2 3 4 def f ( x ): return ( x ** 2 - x - 1 ) print ( bisection ( f , 0 , 10 , 1e-6 ))","title":"EXAMPLE 2"},{"location":"chapter3/3_3_1_Bisection%20Method/#outcome_1","text":"c = 1.6180336475372314","title":"OUTCOME"},{"location":"chapter3/3_3_1_Newton%20Raphson%20Method/","text":"ALGORITHM newton_raphson ( f , f_der , x0 , tol ) Newton-Raphson algorithm for root finding of a single-variable function. Parameters: Name Type Description Default f function single-variable function returning a number. f must be continuous. required f_der function function returning the derivative of f. required x0 float initial solution guess of the problem. required tol float nonnegative tolerance. required Returns: Type Description r (float) root Source code in chapter3\\3_3_1 newton raphson method.py def newton_raphson ( f , f_der , x0 , tol ): \"\"\"Newton-Raphson algorithm for root finding of a single-variable function. Args: f (function): single-variable function returning a number. f must be continuous. f_der (function): function returning the derivative of f. x0 (float): initial solution guess of the problem. tol (float): nonnegative tolerance. Returns: r (float): root \"\"\" r = x0 while abs ( f ( r )) > tol : r = r - float ( f ( r ) / f_der ( r )) return ( r ) EXAMPLE 1 2 3 4 5 def f ( x ): return ( x ** 2 - x - 1 ) def f_der ( x ): return ( 2 * x - 1 ) print ( newton_raphson ( f , f_der , 10 , 1e-6 )) OUTCOME r = 1.6180339887500548","title":"3.3.1. Newton-Raphson method"},{"location":"chapter3/3_3_1_Newton%20Raphson%20Method/#algorithm","text":"","title":"ALGORITHM"},{"location":"chapter3/3_3_1_Newton%20Raphson%20Method/#sourcecode.chapter3.3_3_1 Newton Raphson Method.newton_raphson","text":"Newton-Raphson algorithm for root finding of a single-variable function. Parameters: Name Type Description Default f function single-variable function returning a number. f must be continuous. required f_der function function returning the derivative of f. required x0 float initial solution guess of the problem. required tol float nonnegative tolerance. required Returns: Type Description r (float) root Source code in chapter3\\3_3_1 newton raphson method.py def newton_raphson ( f , f_der , x0 , tol ): \"\"\"Newton-Raphson algorithm for root finding of a single-variable function. Args: f (function): single-variable function returning a number. f must be continuous. f_der (function): function returning the derivative of f. x0 (float): initial solution guess of the problem. tol (float): nonnegative tolerance. Returns: r (float): root \"\"\" r = x0 while abs ( f ( r )) > tol : r = r - float ( f ( r ) / f_der ( r )) return ( r )","title":"newton_raphson()"},{"location":"chapter3/3_3_1_Newton%20Raphson%20Method/#example","text":"1 2 3 4 5 def f ( x ): return ( x ** 2 - x - 1 ) def f_der ( x ): return ( 2 * x - 1 ) print ( newton_raphson ( f , f_der , 10 , 1e-6 ))","title":"EXAMPLE"},{"location":"chapter3/3_3_1_Newton%20Raphson%20Method/#outcome","text":"r = 1.6180339887500548","title":"OUTCOME"},{"location":"chapter3/3_3_4_Gradient%20descent%20line%20search%20with%20backtracking/","text":"ALGORITHM gradient_descent_line_search_with_backtracking ( f , f_der , x0 , tol , a , rho , c ) Gradient descent line search with backtracking for a single-variable function. Parameters: Name Type Description Default f function single-variable function returning a number. f must be continuous. required f_der function function returning the derivative of f. required x0 float initial solution guess of the problem. required tol float nonnegative tolerance of the solution. required a float initialization value of the step length during backtracking. required rho float backtracking parameter. Its value should be within (0,1). required c float Armijo rule parameter. Its value should be within (0,1). required Returns: Type Description x (float) solution Source code in chapter3\\3_3_4 gradient descent line search with backtracking.py def gradient_descent_line_search_with_backtracking ( f , f_der , x0 , tol , a , rho , c ): \"\"\"Gradient descent line search with backtracking for a single-variable function. Args: f (function): single-variable function returning a number. f must be continuous. f_der (function): function returning the derivative of f. x0 (float): initial solution guess of the problem. tol (float): nonnegative tolerance of the solution. a (float): initialization value of the step length during backtracking. rho (float): backtracking parameter. Its value should be within (0,1). c (float): Armijo rule parameter. Its value should be within (0,1). Returns: x (float): solution \"\"\" x = x0 ; k = 0 while ( abs ( f_der ( x )) > tol ): p_k = - f_der ( x ) ## # start of backtracking line search ## a_k = a while f ( x + a_k * p_k ) > f ( x ) + c * a_k * p_k * f_der ( x ): a_k = a_k * rho ## # end of backtracking line search ## # print(k, x, f(x), f_der(x), p_k, a_k) -> uncomment to print the iteration steps x = x + a_k * p_k k = k + 1 return ( x ) EXAMPLE 1 2 3 4 5 6 7 x0 = 5 ; k = 0 ; tol = 0.0001 ; a = 1 ; c = 0.1 ; rho = 0.7 def f ( x ): return ( x ** 2 - 5 * x ) def f_der ( x ): return ( 2 * x - 5 ) print ( gradient_descent_line_search_with_backtracking ( f , f_der , x0 , tol , a , rho , c )) OUTCOME x = 2.5000419430400003","title":"3.3.4. Gradient descent line search with backtracking"},{"location":"chapter3/3_3_4_Gradient%20descent%20line%20search%20with%20backtracking/#algorithm","text":"","title":"ALGORITHM"},{"location":"chapter3/3_3_4_Gradient%20descent%20line%20search%20with%20backtracking/#sourcecode.chapter3.3_3_4 Gradient Descent line search with backtracking.gradient_descent_line_search_with_backtracking","text":"Gradient descent line search with backtracking for a single-variable function. Parameters: Name Type Description Default f function single-variable function returning a number. f must be continuous. required f_der function function returning the derivative of f. required x0 float initial solution guess of the problem. required tol float nonnegative tolerance of the solution. required a float initialization value of the step length during backtracking. required rho float backtracking parameter. Its value should be within (0,1). required c float Armijo rule parameter. Its value should be within (0,1). required Returns: Type Description x (float) solution Source code in chapter3\\3_3_4 gradient descent line search with backtracking.py def gradient_descent_line_search_with_backtracking ( f , f_der , x0 , tol , a , rho , c ): \"\"\"Gradient descent line search with backtracking for a single-variable function. Args: f (function): single-variable function returning a number. f must be continuous. f_der (function): function returning the derivative of f. x0 (float): initial solution guess of the problem. tol (float): nonnegative tolerance of the solution. a (float): initialization value of the step length during backtracking. rho (float): backtracking parameter. Its value should be within (0,1). c (float): Armijo rule parameter. Its value should be within (0,1). Returns: x (float): solution \"\"\" x = x0 ; k = 0 while ( abs ( f_der ( x )) > tol ): p_k = - f_der ( x ) ## # start of backtracking line search ## a_k = a while f ( x + a_k * p_k ) > f ( x ) + c * a_k * p_k * f_der ( x ): a_k = a_k * rho ## # end of backtracking line search ## # print(k, x, f(x), f_der(x), p_k, a_k) -> uncomment to print the iteration steps x = x + a_k * p_k k = k + 1 return ( x )","title":"gradient_descent_line_search_with_backtracking()"},{"location":"chapter3/3_3_4_Gradient%20descent%20line%20search%20with%20backtracking/#example","text":"1 2 3 4 5 6 7 x0 = 5 ; k = 0 ; tol = 0.0001 ; a = 1 ; c = 0.1 ; rho = 0.7 def f ( x ): return ( x ** 2 - 5 * x ) def f_der ( x ): return ( 2 * x - 5 ) print ( gradient_descent_line_search_with_backtracking ( f , f_der , x0 , tol , a , rho , c ))","title":"EXAMPLE"},{"location":"chapter3/3_3_4_Gradient%20descent%20line%20search%20with%20backtracking/#outcome","text":"x = 2.5000419430400003","title":"OUTCOME"}]}